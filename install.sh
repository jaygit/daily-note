#!/usr/bin/env bash
set -euo pipefail

PKG_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Locations (honour XDG if set)
XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
XDG_BIN_HOME="${XDG_BIN_HOME:-$HOME/.local/bin}"
PREFIX_DIR="$XDG_DATA_HOME/daily-note"
SCRIPTS_DIR="$PREFIX_DIR/scripts"
SAMPLE_VAULT_DIR="$PREFIX_DIR/sample-vault"


echo "Installing daily-note to: $PREFIX_DIR"

# Handle uninstall invocation: `install.sh --uninstall` removes installed files
if [ "$#" -gt 0 ]; then
  for _arg in "$@"; do
    if [ "$_arg" = "--uninstall" ]; then
      echo "Uninstalling daily-note from: $PREFIX_DIR"
      removed=()
      if [ -d "$SCRIPTS_DIR" ]; then
        removed+=("$SCRIPTS_DIR")
        rm -rf "$SCRIPTS_DIR"
      fi
      OBS_SHIM="$XDG_BIN_HOME/obs"
      if [ -f "$OBS_SHIM" ]; then
        removed+=("$OBS_SHIM")
        rm -f "$OBS_SHIM"
      fi
      MANPAGE="$PREFIX_DIR/share/man/man1/obs.1"
      if [ -f "$MANPAGE" ]; then
        removed+=("$MANPAGE")
        rm -f "$MANPAGE"
        rmdir --ignore-fail-on-non-empty "$(dirname "$MANPAGE")" 2>/dev/null || true
      fi
      if [ ${#removed[@]} -eq 0 ]; then
        echo "Nothing removed: no installed files found at expected locations."
        exit 0
      fi
      echo "Removed the following files/directories:"
      for f in "${removed[@]}"; do
        echo " - $f"
      done
      exit 0
    fi
  done
fi

mkdir -p "$PREFIX_DIR"
mkdir -p "$XDG_BIN_HOME"

echo "Copying package files..."
RSYNC_AVAILABLE=false
if command -v rsync >/dev/null 2>&1; then
  RSYNC_AVAILABLE=true
fi

# Helper: copy package tree with exclusions. Prefer rsync when available,
# otherwise use tar piped to extract into destination while honoring excludes.
copy_package() {
  local src="$1" dest="$2"
  if [ "$RSYNC_AVAILABLE" = true ]; then
    rsync -a --exclude '.git' --exclude 'tests' --exclude 'dist' --exclude '.venv' "$src/" "$dest/"
  else
    mkdir -p "$dest"
    # Use tar to copy while excluding common directories
    tar -C "$src" \
      --exclude='./.git' \
      --exclude='./tests' \
      --exclude='./dist' \
      --exclude='./.venv' \
      -cf - . | tar -C "$dest" -xpf -
  fi
}

## Only install the scripts directory into the prefix
echo "Copying scripts to: $SCRIPTS_DIR"
mkdir -p "$SCRIPTS_DIR"
if [ "$RSYNC_AVAILABLE" = true ]; then
  rsync -a --exclude '.env' "$PKG_ROOT/scripts/" "$SCRIPTS_DIR/"
else
  cp -a "$PKG_ROOT/scripts/." "$SCRIPTS_DIR/" || true
fi

chmod -R u+rwX,go+rX "$SCRIPTS_DIR"

# Ensure main script is executable
if [ -f "$SCRIPTS_DIR/main.sh" ]; then
  chmod +x "$SCRIPTS_DIR/main.sh"
fi

# Copy installer into prefix so the installed shim can delegate uninstall to it
if [ -f "$PKG_ROOT/install.sh" ]; then
  cp "$PKG_ROOT/install.sh" "$SCRIPTS_DIR/install.sh"
  chmod +x "$SCRIPTS_DIR/install.sh"
fi

# Create `obs` shim in user local bin. The shim supports `--uninstall` which
# will remove the installed scripts, shim and manpage and report what was
# removed. The shim uses the absolute paths chosen at install time.
OBS_SHIM="$XDG_BIN_HOME/obs"
echo "Creating shim: $OBS_SHIM -> $SCRIPTS_DIR/main.sh"
cat > "$OBS_SHIM" <<EOF
#!/usr/bin/env bash
SCRIPTS_DIR="$SCRIPTS_DIR"
# Delegate uninstall to the installer so uninstall logic is centralized.
for __arg in "\$@"; do
  if [ "__arg" = "--uninstall" ] || [ "\$__arg" = "--uninstall" ]; then
    exec "$SCRIPTS_DIR/install.sh" --uninstall
  fi
done

exec "$SCRIPTS_DIR/main.sh" "\$@"
EOF
chmod +x "$OBS_SHIM"

# Notify user if $XDG_BIN_HOME is not in PATH
if ! printf '%s' ":$PATH:" | grep -q ":$XDG_BIN_HOME:"; then
  echo
  echo "Note: $XDG_BIN_HOME is not in your PATH. To make 'obs' available add:" 
  echo "  export PATH=\"$XDG_BIN_HOME:\\$PATH\""
fi

# Prepare .env in scripts dir so lib.sh will find it when installed
ENV_FILE="$SCRIPTS_DIR/.env"
echo "# Generated by install.sh" > "$ENV_FILE"

## Non-interactive / scripted options
INSTALL_SAMPLE=0
YES=0
OVERRIDE_VAULT=""
while [ $# -gt 0 ]; do
  case "$1" in
    --yes)
      YES=1; INSTALL_SAMPLE=1; shift ;;
    --sample-vault)
      INSTALL_SAMPLE=1; shift ;;
    --vault-path)
      OVERRIDE_VAULT="$2"; shift 2 ;;
    --help)
      echo "Usage: $0 [--yes|--sample-vault|--vault-path <path>]"; exit 0 ;;
    *) echo "Unknown option: $1"; exit 2 ;;
  esac
done

if [ -n "$OVERRIDE_VAULT" ]; then
  VAULT_PATH="$OVERRIDE_VAULT"
  VAULT_PATH="${VAULT_PATH/#\~/$HOME}"
  if [ -d "$VAULT_PATH" ]; then
    echo "VAULT_DIR=$VAULT_PATH" >> "$ENV_FILE"
    echo "Configured VAULT_DIR -> $VAULT_PATH"
  else
    echo "Provided vault path does not exist: $VAULT_PATH" >&2
    exit 2
  fi
elif [ "$INSTALL_SAMPLE" -eq 1 ]; then
  mkdir -p "$SAMPLE_VAULT_DIR"
  if [ -d "$PKG_ROOT/notes/samples" ]; then
    if [ "$RSYNC_AVAILABLE" = true ]; then
      rsync -a "$PKG_ROOT/notes/samples/" "$SAMPLE_VAULT_DIR/"
    else
      mkdir -p "$SAMPLE_VAULT_DIR"
      cp -a "$PKG_ROOT/notes/samples/." "$SAMPLE_VAULT_DIR/" || true
    fi
  fi
  echo "VAULT_DIR=$SAMPLE_VAULT_DIR" >> "$ENV_FILE"
  echo "Installed sample vault at: $SAMPLE_VAULT_DIR"
else
  if [ "$YES" -eq 1 ]; then
    # default to sample vault if --yes provided
    mkdir -p "$SAMPLE_VAULT_DIR"
    if [ -d "$PKG_ROOT/notes/samples" ]; then
        if [ "$RSYNC_AVAILABLE" = true ]; then
          rsync -a "$PKG_ROOT/notes/samples/" "$SAMPLE_VAULT_DIR/"
        else
          cp -a "$PKG_ROOT/notes/samples/." "$SAMPLE_VAULT_DIR/" || true
        fi
    fi
    echo "VAULT_DIR=$SAMPLE_VAULT_DIR" >> "$ENV_FILE"
    echo "Installed sample vault at: $SAMPLE_VAULT_DIR"
  else
    # interactive fallback
    read -rp "Install sample vault to $SAMPLE_VAULT_DIR? (y/N) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      mkdir -p "$SAMPLE_VAULT_DIR"
      if [ -d "$PKG_ROOT/notes/samples" ]; then
          if [ "$RSYNC_AVAILABLE" = true ]; then
            rsync -a "$PKG_ROOT/notes/samples/" "$SAMPLE_VAULT_DIR/"
          else
            cp -a "$PKG_ROOT/notes/samples/." "$SAMPLE_VAULT_DIR/" || true
          fi
      fi
      echo "VAULT_DIR=$SAMPLE_VAULT_DIR" >> "$ENV_FILE"
      echo "Installed sample vault at: $SAMPLE_VAULT_DIR"
    else
      # ask if user has existing vault
      read -rp "Do you have an existing vault to use? (y/N) " -n 1 -r
      echo
      if [[ $REPLY =~ ^[Yy]$ ]]; then
        read -rp "Enter path to your vault directory: " VAULT_PATH
        VAULT_PATH="${VAULT_PATH/#\~/$HOME}"
        if [ -d "$VAULT_PATH" ]; then
          echo "VAULT_DIR=$VAULT_PATH" >> "$ENV_FILE"
          echo "Configured VAULT_DIR -> $VAULT_PATH"
        else
          echo "Path does not exist: $VAULT_PATH" >&2
          echo "Leaving VAULT_DIR unset. You can edit $ENV_FILE later." >&2
        fi
      else
        echo "No vault configured. You can edit $ENV_FILE later to set VAULT_DIR." >&2
      fi
    fi
  fi
fi

# If VAULT_DIR is set, check git remotes and offer to configure gitea remote
VAULT_DIR_SET=$(grep -E '^VAULT_DIR=' "$ENV_FILE" || true)
if [ -n "$VAULT_DIR_SET" ]; then
  VAULT_DIR_VAL=$(sed -n 's/^VAULT_DIR=//p' "$ENV_FILE" | tr -d '"')
  if [ -d "$VAULT_DIR_VAL/.git" ] || git -C "$VAULT_DIR_VAL" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo "Detected git repository in vault: $VAULT_DIR_VAL"
    # List remotes
    git -C "$VAULT_DIR_VAL" remote -v
    if git -C "$VAULT_DIR_VAL" remote | grep -qx gitea; then
      echo "Remote 'gitea' already present." 
      GIT_URL=$(git -C "$VAULT_DIR_VAL" remote get-url gitea 2>/dev/null || true)
      if [ -n "$GIT_URL" ]; then
        echo "GIT_REMOTE_NAME=gitea" >> "$ENV_FILE"
        echo "GIT_REMOTE_URL=$GIT_URL" >> "$ENV_FILE"
      fi
    else
      # If other remotes exist, offer to map one to 'gitea'
      existing_remotes=$(git -C "$VAULT_DIR_VAL" remote)
      if [ -n "$existing_remotes" ]; then
        echo "Available remotes: $existing_remotes"
        read -rp "Would you like to add one of these remotes as 'gitea'? (y/N) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
          echo "Choose a remote to alias as 'gitea':"
          select r in $existing_remotes; do
            if [ -n "$r" ]; then
              url=$(git -C "$VAULT_DIR_VAL" remote get-url "$r")
              git -C "$VAULT_DIR_VAL" remote add gitea "$url"
              echo "Added remote gitea -> $url"
              echo "GIT_REMOTE_NAME=gitea" >> "$ENV_FILE"
              echo "GIT_REMOTE_URL=$url" >> "$ENV_FILE"
              break
            fi
          done
        fi
      else
        # no remotes: ask to add one
        read -rp "No remotes found. Add a remote URL now to create 'gitea'? (y/N) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
          read -rp "Enter remote git URL (ssh or https): " remote_url
          git -C "$VAULT_DIR_VAL" remote add gitea "$remote_url"
          echo "Added remote gitea -> $remote_url"
          echo "GIT_REMOTE_NAME=gitea" >> "$ENV_FILE"
          echo "GIT_REMOTE_URL=$remote_url" >> "$ENV_FILE"
        fi
      fi
    fi
  fi
fi

cat <<EOF
Installation complete.

Installed to: $PREFIX_DIR
Command shim: $OBS_SHIM
Env file: $ENV_FILE

You can edit $ENV_FILE to tweak settings (e.g. VAULT_DIR).
Run 'obs' to start the main tool.
EOF

# Recommend installing optional utilities for best experience
missing=()
if ! command -v rg >/dev/null 2>&1; then
  missing+=("ripgrep (rg)")
fi
if ! command -v fzf >/dev/null 2>&1; then
  missing+=("fzf")
fi
if ! command -v batcat >/dev/null 2>&1 && ! command -v bat >/dev/null 2>&1; then
  missing+=("bat (batcat)")
fi
if [ ${#missing[@]} -gt 0 ]; then
  echo
  echo "Note: daily-note works best if the following utilities are installed:"
  printf ' - %s\n' "${missing[@]}"
  echo "Install them via your package manager (apt, yum, brew, etc.) for full functionality."
fi

# Install a minimal manpage for `obs` under the prefix so users can add it to
# their MANPATH if they wish. This is optional but useful for completion.
## Install manpage preferentially into an existing writable manpath so
## `man obs` works immediately without the user changing MANPATH.
man_src="$PKG_ROOT/man/obs.1"
installed_man=""
if [ -f "$man_src" ]; then
  # Get system manpath list; fallback to common locations
  manpath_list=$(manpath 2>/dev/null || echo "$XDG_DATA_HOME/share/man:/usr/local/share/man:/usr/share/man")
  IFS=':' read -ra paths <<<"$manpath_list"
  for base in "${paths[@]}"; do
    [ -z "$base" ] && continue
    target="$base/man1"
    # If directory exists and writable, use it. If it doesn't exist but parent is writable, create it.
    if [ -d "$target" ] && [ -w "$target" ]; then
      mkdir -p "$target"
      cp "$man_src" "$target/obs.1"
      installed_man="$target/obs.1"
      break
    elif [ ! -d "$target" ] && [ -w "$base" ]; then
      mkdir -p "$target"
      cp "$man_src" "$target/obs.1"
      installed_man="$target/obs.1"
      break
    fi
  done
fi

# If not installed into a system manpath, fall back to the user prefix man dir
if [ -z "$installed_man" ]; then
  MAN_DIR="$PREFIX_DIR/share/man/man1"
  mkdir -p "$MAN_DIR"
  if [ -f "$man_src" ]; then
    cp "$man_src" "$MAN_DIR/obs.1"
  else
    # fallback minimal manpage if source missing
    cat > "$MAN_DIR/obs.1" <<'MAN'
.TH obs 1 "2025-12-13" "daily-note"
.SH NAME
obs \- helper shim for daily-note
.SH SYNOPSIS
.B obs
[-\-uninstall]
.SH DESCRIPTION
obs is a tiny shim that dispatches to the daily-note scripts installed
under the user's data prefix. Use
.B obs \-\-uninstall
to remove installed files created by the installer.
.SH NOTES
The manpage is installed under the user prefix; add the prefix man directory
to your MANPATH if you want "man obs" to find it.
MAN
  fi
  installed_man="$MAN_DIR/obs.1"
  echo
  echo "Manpage installed to: $installed_man"
  echo "If 'man obs' does not show this page, add $PREFIX_DIR/share/man to your MANPATH or run:"
  echo "  man -M $PREFIX_DIR/share/man obs"
else
  echo
  echo "Manpage installed to system manpath: $installed_man"
fi

exit 0
