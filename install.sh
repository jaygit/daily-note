#!/usr/bin/env bash
set -euo pipefail

PKG_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Locations (honour XDG if set)
XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
XDG_BIN_HOME="${XDG_BIN_HOME:-$HOME/.local/bin}"
PREFIX_DIR="$XDG_DATA_HOME/daily-note"
SCRIPTS_DIR="$PREFIX_DIR/scripts"
SAMPLE_VAULT_DIR="$PREFIX_DIR/sample-vault"


echo "Installing daily-note to: $PREFIX_DIR"

MANIFEST_FILE="$PREFIX_DIR/.installed_files"

# Handle uninstall invocation: `install.sh --uninstall` removes installed files
if [ "$#" -gt 0 ]; then
  for _arg in "$@"; do
    if [ "$_arg" = "--uninstall" ] || [ "$_arg" = "--remove" ]; then
      echo "Uninstalling daily-note from: $PREFIX_DIR"
      removed=()
      # If a manifest exists, remove files listed there (one-per-line)
      if [ -f "$MANIFEST_FILE" ]; then
        while IFS= read -r p; do
          [ -z "$p" ] && continue
          if [ -e "$p" ]; then
            removed+=("$p")
            if [ -d "$p" ]; then
              rm -rf "$p"
            else
              rm -f "$p"
            fi
          fi
        done < "$MANIFEST_FILE"
        rm -f "$MANIFEST_FILE"
      else
        # Fallback: try to remove expected locations
        if [ -d "$SCRIPTS_DIR" ]; then
          removed+=("$SCRIPTS_DIR")
          rm -rf "$SCRIPTS_DIR"
        fi
        OBS_SHIM="$XDG_BIN_HOME/obs"
        if [ -f "$OBS_SHIM" ]; then
          removed+=("$OBS_SHIM")
          rm -f "$OBS_SHIM"
        fi
        JOT_SHIM="$XDG_BIN_HOME/jot"
        if [ -f "$JOT_SHIM" ]; then
          removed+=("$JOT_SHIM")
          rm -f "$JOT_SHIM"
        fi
        CANVAS_SHIM="$XDG_BIN_HOME/canvas"
        if [ -f "$CANVAS_SHIM" ]; then
          removed+=("$CANVAS_SHIM")
          rm -f "$CANVAS_SHIM"
        fi
        MANPAGE="$PREFIX_DIR/share/man/man1/obs.1"
        if [ -f "$MANPAGE" ]; then
          removed+=("$MANPAGE")
          rm -f "$MANPAGE"
          rmdir --ignore-fail-on-non-empty "$(dirname "$MANPAGE")" 2>/dev/null || true
        fi
      fi

      if [ ${#removed[@]} -eq 0 ]; then
        echo "Nothing removed: no installed files found at expected locations."
        exit 0
      fi
      echo "Removed the following files/directories:"
      for f in "${removed[@]}"; do
        echo " - $f"
      done
      exit 0
    fi
  done
fi

## Parse options early so `--help` doesn't perform installs
INSTALL_SAMPLE=0
YES=0
OVERRIDE_VAULT=""
while [ $# -gt 0 ]; do
  case "$1" in
    --yes)
      YES=1; INSTALL_SAMPLE=1; shift ;;
    --sample-vault)
      INSTALL_SAMPLE=1; shift ;;
    --vault-path)
      OVERRIDE_VAULT="$2"; shift 2 ;;
    --help)
      echo "Usage: $0 [--yes|--sample-vault|--vault-path <path>]"; exit 0 ;;
    *) echo "Unknown option: $1"; exit 2 ;;
  esac
done

mkdir -p "$PREFIX_DIR"
mkdir -p "$XDG_BIN_HOME"

echo "Copying package files..."
RSYNC_AVAILABLE=false
if command -v rsync >/dev/null 2>&1; then
  RSYNC_AVAILABLE=true
fi

# Helper: copy package tree with exclusions. Prefer rsync when available,
# otherwise use tar piped to extract into destination while honoring excludes.
copy_package() {
  local src="$1" dest="$2"
  if [ "$RSYNC_AVAILABLE" = true ]; then
    rsync -a --exclude '.git' --exclude 'tests' --exclude 'dist' --exclude '.venv' "$src/" "$dest/"
  else
    mkdir -p "$dest"
    # Use tar to copy while excluding common directories
    tar -C "$src" \
      --exclude='./.git' \
      --exclude='./tests' \
      --exclude='./dist' \
      --exclude='./.venv' \
      -cf - . | tar -C "$dest" -xpf -
  fi
}

## Only install the scripts directory into the prefix
echo "Copying scripts to: $SCRIPTS_DIR"
mkdir -p "$SCRIPTS_DIR"
if [ "$RSYNC_AVAILABLE" = true ]; then
  rsync -a --exclude '.env' "$PKG_ROOT/scripts/" "$SCRIPTS_DIR/"
else
  cp -a "$PKG_ROOT/scripts/." "$SCRIPTS_DIR/" || true
fi

chmod -R u+rwX,go+rX "$SCRIPTS_DIR"

# Ensure main script is executable
if [ -f "$SCRIPTS_DIR/main.sh" ]; then
  chmod +x "$SCRIPTS_DIR/main.sh"
fi

# Prepare .env in scripts dir so runtime can read settings early
ENV_FILE="$SCRIPTS_DIR/.env"
echo "# Generated by install.sh" > "$ENV_FILE"

# If user has a global $HOME/.env with VAULT_DIR, prefer that as a default
if [ -f "$HOME/.env" ]; then
  HOME_VAULT_LINE=$(grep -E '^VAULT_DIR=' "$HOME/.env" || true)
  if [ -n "$HOME_VAULT_LINE" ]; then
    HOME_VAULT_VAL=$(sed -n 's/^VAULT_DIR=//p' "$HOME/.env" | tr -d '"')
    if [ -n "$HOME_VAULT_VAL" ]; then
      echo "VAULT_DIR=\"$HOME_VAULT_VAL\"" >> "$ENV_FILE"
      echo "Configured VAULT_DIR from $HOME/.env -> $HOME_VAULT_VAL"
    fi
  fi
fi

# Determine package version (prefer RELEASE_NOTES/v.*.md, else git tag) and
# write it to the installed env file so runtime can read `$VERSION`.
VERSION_VAL=""
if compgen -G "$PKG_ROOT/RELEASE_NOTES/v.*.md" >/dev/null 2>&1; then
  VERSION_VAL=$(ls "$PKG_ROOT/RELEASE_NOTES"/v.*.md 2>/dev/null | xargs -n1 basename | sed 's/\.md$//' | sort -V | tail -n1)
elif git -C "$PKG_ROOT" describe --tags --abbrev=0 >/dev/null 2>&1; then
  VERSION_VAL=$(git -C "$PKG_ROOT" describe --tags --abbrev=0 2>/dev/null)
fi
if [ -n "$VERSION_VAL" ]; then
  echo "VERSION=$VERSION_VAL" >> "$ENV_FILE"
fi

# Ensure jot script is executable when present
if [ -f "$SCRIPTS_DIR/jot.sh" ]; then
  chmod +x "$SCRIPTS_DIR/jot.sh"
fi

# Ensure mknb-canvas script is executable when present
if [ -f "$SCRIPTS_DIR/mknb-canvas.py" ]; then
  chmod +x "$SCRIPTS_DIR/mknb-canvas.py"
fi

# Copy installer into prefix so the installed shim can delegate uninstall to it
if [ -f "$PKG_ROOT/install.sh" ]; then
  cp "$PKG_ROOT/install.sh" "$SCRIPTS_DIR/install.sh"
  chmod +x "$SCRIPTS_DIR/install.sh"
fi

# Create `obs` shim in user local bin. The shim supports `--uninstall` which
# will remove the installed scripts, shim and manpage and report what was
# removed. The shim uses the absolute paths chosen at install time.
OBS_SHIM="$XDG_BIN_HOME/obs"
echo "Creating shim: $OBS_SHIM -> $SCRIPTS_DIR/main.sh"
cat > "$OBS_SHIM" <<EOF
#!/usr/bin/env bash
SCRIPTS_DIR="$SCRIPTS_DIR"
# Delegate uninstall to the installer so uninstall logic is centralized.
  for __arg in "\$@"; do
  if [ "__arg" = "--uninstall" ] || [ "\$__arg" = "--uninstall" ] || [ "__arg" = "--remove" ] || [ "\$__arg" = "--remove" ]; then
    exec "$SCRIPTS_DIR/install.sh" --uninstall
  fi
done

exec "$SCRIPTS_DIR/main.sh" "\$@"
EOF
chmod +x "$OBS_SHIM"

# Create `jot` shim in user local bin that executes the installed jot script
JOT_SHIM="$XDG_BIN_HOME/jot"
echo "Creating shim: $JOT_SHIM -> $SCRIPTS_DIR/jot.sh"
cat > "$JOT_SHIM" <<EOF
#!/usr/bin/env bash
SCRIPTS_DIR="$SCRIPTS_DIR"
exec "$SCRIPTS_DIR/jot.sh" "\$@"
EOF
chmod +x "$JOT_SHIM"

# Create `canvas` shim in user local bin that executes the installed mknb-canvas script
CANVAS_SHIM="$XDG_BIN_HOME/canvas"
echo "Creating shim: $CANVAS_SHIM -> $SCRIPTS_DIR/mknb-canvas.sh"
cat > "$CANVAS_SHIM" <<EOF
#!/usr/bin/env bash
SCRIPTS_DIR="$SCRIPTS_DIR"
exec "$SCRIPTS_DIR/mknb-canvas.py" "\$@"
EOF
chmod +x "$CANVAS_SHIM"

# Record installed files so uninstall can remove them reliably
mkdir -p "$PREFIX_DIR"
MANIFEST_FILE="$PREFIX_DIR/.installed_files"
printf "%s\n" "$SCRIPTS_DIR" "$OBS_SHIM" "$JOT_SHIM" "$CANVAS_SHIM" > "$MANIFEST_FILE"

# Notify user if $XDG_BIN_HOME is not in PATH
if ! printf '%s' ":$PATH:" | grep -q ":$XDG_BIN_HOME:"; then
  echo
  echo "Note: $XDG_BIN_HOME is not in your PATH. To make 'obs', 'jot' and 'canvas' available add:" 
  echo "  export PATH=\"$XDG_BIN_HOME:\\$PATH\""
fi

# If the installer was given --vault-path, record it into the installed env file
if [ -n "${OVERRIDE_VAULT:-}" ]; then
  VAULT_PATH="$OVERRIDE_VAULT"
  VAULT_PATH="${VAULT_PATH/#\~/$HOME}"
  if [ -d "$VAULT_PATH" ]; then
    # Replace existing VAULT_DIR entry if present, otherwise append
    if grep -q -E '^VAULT_DIR=' "$ENV_FILE"; then
      sed -i "s|^VAULT_DIR=.*|VAULT_DIR=\"$VAULT_PATH\"|" "$ENV_FILE"
    else
      echo "VAULT_DIR=\"$VAULT_PATH\"" >> "$ENV_FILE"
    fi
    echo "Configured VAULT_DIR -> $VAULT_PATH"
  else
    echo "Provided vault path does not exist: $VAULT_PATH" >&2
    exit 2
  fi
fi

# If VAULT_DIR is set, check git remotes and offer to configure gitea remote
VAULT_DIR_SET=$(grep -E '^VAULT_DIR=' "$ENV_FILE" || true)
if [ -n "$VAULT_DIR_SET" ]; then
  VAULT_DIR_VAL=$(sed -n 's/^VAULT_DIR=//p' "$ENV_FILE" | tr -d '"')
  if [ -d "$VAULT_DIR_VAL/.git" ] || git -C "$VAULT_DIR_VAL" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo "Detected git repository in vault: $VAULT_DIR_VAL"
    # List remotes
    git -C "$VAULT_DIR_VAL" remote -v
    if git -C "$VAULT_DIR_VAL" remote | grep -qx gitea; then
      echo "Remote 'gitea' already present." 
      GIT_URL=$(git -C "$VAULT_DIR_VAL" remote get-url gitea 2>/dev/null || true)
      if [ -n "$GIT_URL" ]; then
        echo "GIT_REMOTE_NAME=gitea" >> "$ENV_FILE"
        echo "GIT_REMOTE_URL=$GIT_URL" >> "$ENV_FILE"
      fi
    else
      # If other remotes exist, offer to map one to 'gitea'
      existing_remotes=$(git -C "$VAULT_DIR_VAL" remote)
      if [ -n "$existing_remotes" ]; then
        echo "Available remotes: $existing_remotes"
        read -rp "Would you like to add one of these remotes as 'gitea'? (y/N) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
          echo "Choose a remote to alias as 'gitea':"
          select r in $existing_remotes; do
            if [ -n "$r" ]; then
              url=$(git -C "$VAULT_DIR_VAL" remote get-url "$r")
              git -C "$VAULT_DIR_VAL" remote add gitea "$url"
              echo "Added remote gitea -> $url"
              echo "GIT_REMOTE_NAME=gitea" >> "$ENV_FILE"
              echo "GIT_REMOTE_URL=$url" >> "$ENV_FILE"
              break
            fi
          done
        fi
      else
        # no remotes: ask to add one
        read -rp "No remotes found. Add a remote URL now to create 'gitea'? (y/N) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
          read -rp "Enter remote git URL (ssh or https): " remote_url
          git -C "$VAULT_DIR_VAL" remote add gitea "$remote_url"
          echo "Added remote gitea -> $remote_url"
          echo "GIT_REMOTE_NAME=gitea" >> "$ENV_FILE"
          echo "GIT_REMOTE_URL=$remote_url" >> "$ENV_FILE"
        fi
      fi
    fi
  fi
fi

cat <<EOF
Installation complete.

Installed to: $PREFIX_DIR
Command shims: $OBS_SHIM, $JOT_SHIM and $CANVAS_SHIM
Env file: $ENV_FILE

You can edit $ENV_FILE to tweak settings (e.g. VAULT_DIR).
Run 'obs' to start the main tool. Use 'jot' for quick entries and 'canvas' for mknb canvas operations.
EOF

# Recommend installing optional utilities for best experience
missing=()
if ! command -v rg >/dev/null 2>&1; then
  missing+=("ripgrep (rg)")
fi
if ! command -v fzf >/dev/null 2>&1; then
  missing+=("fzf")
fi
if ! command -v batcat >/dev/null 2>&1 && ! command -v bat >/dev/null 2>&1; then
  missing+=("bat (batcat)")
fi
if [ ${#missing[@]} -gt 0 ]; then
  echo
  echo "Note: daily-note works best if the following utilities are installed:"
  printf ' - %s\n' "${missing[@]}"
  echo "Install them via your package manager (apt, yum, brew, etc.) for full functionality."
fi

# Install a minimal manpage for `obs` under the prefix so users can add it to
# their MANPATH if they wish. This is optional but useful for completion.
## Install manpage preferentially into an existing writable manpath so
## `man obs` works immediately without the user changing MANPATH.
man_src="$PKG_ROOT/man/obs.1"
installed_man=""
if [ -f "$man_src" ]; then
  # Get system manpath list; fallback to common locations
  manpath_list=$(manpath 2>/dev/null || echo "$XDG_DATA_HOME/share/man:/usr/local/share/man:/usr/share/man")
  IFS=':' read -ra paths <<<"$manpath_list"
  for base in "${paths[@]}"; do
    [ -z "$base" ] && continue
    target="$base/man1"
    # If directory exists and writable, use it. If it doesn't exist but parent is writable, create it.
    if [ -d "$target" ] && [ -w "$target" ]; then
      mkdir -p "$target"
      cp "$man_src" "$target/obs.1"
      installed_man="$target/obs.1"
      # record installed manpage path
      printf "%s\n" "$installed_man" >> "$MANIFEST_FILE"
      break
    elif [ ! -d "$target" ] && [ -w "$base" ]; then
      mkdir -p "$target"
      cp "$man_src" "$target/obs.1"
      installed_man="$target/obs.1"
      # record installed manpage path
      printf "%s\n" "$installed_man" >> "$MANIFEST_FILE"
      break
    fi
  done
fi

# If not installed into a system manpath, fall back to the user prefix man dir
if [ -z "$installed_man" ]; then
  MAN_DIR="$PREFIX_DIR/share/man/man1"
  mkdir -p "$MAN_DIR"
  if [ -f "$man_src" ]; then
    cp "$man_src" "$MAN_DIR/obs.1"
    # record installed manpage path
    printf "%s\n" "$MAN_DIR/obs.1" >> "$MANIFEST_FILE"
  else
    # fallback minimal manpage if source missing
    cat > "$MAN_DIR/obs.1" <<'MAN'
.TH obs 1 "2025-12-13" "daily-note"
.SH NAME
obs \- helper shim for daily-note
.SH SYNOPSIS
.B obs
[-\-uninstall]
.SH DESCRIPTION
obs is a tiny shim that dispatches to the daily-note scripts installed
under the user's data prefix. Use
.B obs \-\-uninstall
to remove installed files created by the installer.
.SH NOTES
The manpage is installed under the user prefix; add the prefix man directory
to your MANPATH if you want "man obs" to find it.
MAN
  fi
  installed_man="$MAN_DIR/obs.1"
  # record installed manpage path
  printf "%s\n" "$installed_man" >> "$MANIFEST_FILE"
  echo
  echo "Manpage installed to: $installed_man"
  echo "If 'man obs' does not show this page, add $PREFIX_DIR/share/man to your MANPATH or run:"
  echo "  man -M $PREFIX_DIR/share/man obs"
else
  echo
  echo "Manpage installed to system manpath: $installed_man"
fi

exit 0
